name: Official Docker Hub Publish

on:
  release:
    types: [published]
  workflow_dispatch:
  workflow_call:
    secrets:
      DOCKERHUB_TOKEN:
        required: true

permissions:
  contents: read
  attestations: write
  id-token: write

jobs:
  publish-dockerhub:
    name: Push ${{ matrix.variant }} image to Docker Hub
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - variant: azurelinux
            dockerfile: docker/azurelinux/Dockerfile
            description: Azure Linux distroless runtime
          - variant: debian
            dockerfile: docker/debian/Dockerfile
            description: Debian bookworm slim runtime
    env:
      DOCKERHUB_REPO: hcoona/noip-duc
      DOCKERHUB_SUBJECT: index.docker.io/hcoona/noip-duc
      DOCKERHUB_IMAGE: docker.io/hcoona/noip-duc
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Configure Docker daemon (containerd snapshotter)
        uses: docker/setup-docker-action@v4
        with:
          daemon-config: |
            {
              "debug": true,
              "experimental": true,
              "features": {
                "containerd-snapshotter": true
              }
            }

      - name: Capture Docker socket path
        id: docker_socket
        run: |
          url=$(docker context inspect | jq -r '.[0].Endpoints.docker.Host')
          socket_path="${url#unix://}"
          echo "path=${socket_path}" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install Syft
        uses: anchore/sbom-action/download-syft@v0.21.0

      - name: Install Cosign
        uses: sigstore/cosign-installer@v4.0.0
        with:
          cosign-release: 'v3.0.2'

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: hcoona
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Determine version metadata
        id: versions
        run: |
          set -euo pipefail
          crate_version="$(awk 'match($0,/^version\s*=\s*"([^"]+)"/,m){print m[1]; exit}' Cargo.toml)"
          if [[ -z "$crate_version" ]]; then
            echo "Unable to parse crate version from Cargo.toml" >&2
            exit 1
          fi
          dockerfile="${{ matrix.dockerfile }}"
          rust_version="$(grep -m1 '^ARG RUST_VERSION=' "$dockerfile" | cut -d= -f2 | tr -d '"')"
          rust_version="${rust_version//$'\r'/}"
          if [[ -z "$rust_version" ]]; then
            echo "Unable to determine RUST_VERSION from $dockerfile" >&2
            exit 1
          fi
          case "${{ matrix.variant }}" in
            azurelinux)
              os_version="$(grep -m1 '^FROM mcr\.microsoft\.com/azurelinux/distroless/base:' "$dockerfile" | sed -E 's/.*base:([[:alnum:].-]+).*/\1/')"
              os_version="${os_version//$'\r'/}"
              if [[ -z "$os_version" ]]; then
                os_version="3.0"
              fi
              os_tag="azurelinux${os_version}"
              ;;
            debian)
              os_version="$(grep -m1 '^ARG DEBIAN_VERSION=' "$dockerfile" | cut -d= -f2 | tr -d '"')"
              os_version="${os_version//$'\r'/}"
              if [[ -z "$os_version" ]]; then
                echo "Unable to determine DEBIAN_VERSION from $dockerfile" >&2
                exit 1
              fi
              os_tag="debian-${os_version}"
              ;;
            *)
              echo "Unsupported variant ${{ matrix.variant }}" >&2
              exit 1
              ;;
          esac
          tag="${crate_version}-rust${rust_version}-${os_tag}"
          patched_tag="${tag}"
          local_tag="${tag}-candidate"
          {
            echo "crate_version=${crate_version}"
            echo "rust_version=${rust_version}"
            echo "os_tag=${os_tag}"
            echo "tag=${tag}"
            echo "patched_tag=${patched_tag}"
            echo "local_tag=${local_tag}"
          } >> "$GITHUB_OUTPUT"

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKERHUB_REPO }}
          flavor: |
            latest=false
          tags: |
            type=raw,value=${{ steps.versions.outputs.tag }}
          labels: |
            org.opencontainers.image.description=${{ matrix.description }} image for Docker Hub

      - name: Build ${{ matrix.variant }} image (local only)
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64
          push: false
          load: true
          tags: ${{ env.DOCKERHUB_IMAGE }}:${{ steps.versions.outputs.local_tag }}

      - name: Scan image for OS vulnerabilities (Trivy)
        id: trivy
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: image
          image-ref: ${{ env.DOCKERHUB_IMAGE }}:${{ steps.versions.outputs.local_tag }}
          format: json
          output: trivy-${{ matrix.variant }}.json
          ignore-unfixed: true
          vuln-type: os

      - name: Count fixable OS vulnerabilities
        id: vuln_count
        run: |
          report="trivy-${{ matrix.variant }}.json"
          count=$(jq 'if .Results then [.Results[] | select(.Class=="os-pkgs" and .Vulnerabilities!=null) | .Vulnerabilities[] | select(.FixedVersion!=null and .FixedVersion!="")] | length else 0 end' "$report")
          echo "count=${count}" >> "$GITHUB_OUTPUT"

      - name: Patch image with Copacetic
        if: steps.vuln_count.outputs.count != '0'
        id: copa
        uses: project-copacetic/copa-action@v1.2.1
        with:
          image: ${{ env.DOCKERHUB_IMAGE }}:${{ steps.versions.outputs.local_tag }}
          image-report: trivy-${{ matrix.variant }}.json
          patched-tag: ${{ steps.versions.outputs.patched_tag }}
          timeout: 10m
          custom-socket: ${{ steps.docker_socket.outputs.path }}
          output: copa-${{ matrix.variant }}.json

      - name: Push Copacetic patched image
        if: steps.copa.outcome == 'success'
        run: docker push ${{ env.DOCKERHUB_IMAGE }}:${{ steps.versions.outputs.patched_tag }}

      - name: Resolve patched image digest
        if: steps.copa.outcome == 'success'
        id: patched_digest
        env:
          PATCHED_REF: ${{ env.DOCKERHUB_SUBJECT }}:${{ steps.versions.outputs.patched_tag }}
        run: |
          digest=$(docker buildx imagetools inspect "${PATCHED_REF}" --format '{{json .Manifest.Digest}}' | tr -d '"')
          base_ref="${PATCHED_REF%:*}"
          ref="${base_ref}@${digest}"
          echo "ref=${ref}" >> "$GITHUB_OUTPUT"
          echo "digest=${digest}" >> "$GITHUB_OUTPUT"

      - name: Generate SBOM for Copacetic Docker Hub image
        if: steps.copa.outcome == 'success'
        run: syft "${{ steps.patched_digest.outputs.ref }}" -o spdx-json > "sbom-${{ matrix.variant }}-patched.json"

      - name: Attach SBOM to Copacetic Docker Hub image
        if: steps.copa.outcome == 'success'
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: cosign attest --yes --predicate "sbom-${{ matrix.variant }}-patched.json" --type https://spdx.dev/Document "${{ steps.patched_digest.outputs.ref }}"

      - name: Tag release image
        if: steps.vuln_count.outputs.count == '0'
        env:
          SOURCE_TAG: ${{ steps.versions.outputs.local_tag }}
          RELEASE_TAG: ${{ steps.versions.outputs.tag }}
        run: |
          docker tag "${DOCKERHUB_IMAGE}:${SOURCE_TAG}" "${DOCKERHUB_IMAGE}:${RELEASE_TAG}"

      - name: Push release image
        if: steps.vuln_count.outputs.count == '0'
        env:
          RELEASE_REF: ${{ env.DOCKERHUB_IMAGE }}:${{ steps.versions.outputs.tag }}
        run: docker push "${RELEASE_REF}"

      - name: Resolve release image digest
        if: steps.vuln_count.outputs.count == '0'
        id: release_digest
        env:
          RELEASE_REF: ${{ env.DOCKERHUB_SUBJECT }}:${{ steps.versions.outputs.tag }}
        run: |
          digest=$(docker buildx imagetools inspect "${RELEASE_REF}" --format '{{json .Manifest.Digest}}' | tr -d '"')
          base_ref="${RELEASE_REF%:*}"
          ref="${base_ref}@${digest}"
          echo "ref=${ref}" >> "$GITHUB_OUTPUT"
          echo "digest=${digest}" >> "$GITHUB_OUTPUT"

      - name: Generate SBOM for Docker Hub image
        if: steps.vuln_count.outputs.count == '0'
        run: syft "${{ steps.release_digest.outputs.ref }}" -o spdx-json > "sbom-${{ matrix.variant }}.json"

      - name: Attach SBOM to Docker Hub image
        if: steps.vuln_count.outputs.count == '0'
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: cosign attest --yes --predicate "sbom-${{ matrix.variant }}.json" --type https://spdx.dev/Document "${{ steps.release_digest.outputs.ref }}"

      - name: Sign Docker Hub image with Cosign
        if: steps.vuln_count.outputs.count == '0'
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: cosign sign --yes "${{ steps.release_digest.outputs.ref }}"

      - name: Sign patched Docker Hub image with Cosign
        if: steps.copa.outcome == 'success'
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: cosign sign --yes "${{ steps.patched_digest.outputs.ref }}"

      - name: Attest Docker Hub image with Cosign
        if: steps.vuln_count.outputs.count == '0'
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          cat <<EOF > provenance.json
          {
            "buildDefinition": {
              "buildType": "https://github.com/actions/build",
              "externalParameters": {
                "workflow": "${GITHUB_WORKFLOW}",
                "run_id": "${GITHUB_RUN_ID}",
                "run_attempt": "${GITHUB_RUN_ATTEMPT}"
              },
              "resolvedDependencies": [
                {
                  "uri": "git+https://github.com/${GITHUB_REPOSITORY}",
                  "digest": {
                    "gitCommit": "${GITHUB_SHA}"
                  }
                }
              ]
            },
            "runDetails": {
              "builder": {
                "id": "https://github.com/${GITHUB_REPOSITORY}/.github/workflows/${GITHUB_WORKFLOW}"
              },
              "metadata": {
                "invocationId": "https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
              }
            }
          }
          EOF
          cosign attest --yes --predicate provenance.json --type https://slsa.dev/provenance/v1 "${{ steps.release_digest.outputs.ref }}"

      - name: Attest Copacetic Docker Hub image with Cosign
        if: steps.copa.outcome == 'success'
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          cat <<EOF > provenance.json
          {
            "buildDefinition": {
              "buildType": "https://github.com/actions/build",
              "externalParameters": {
                "workflow": "${GITHUB_WORKFLOW}",
                "run_id": "${GITHUB_RUN_ID}",
                "run_attempt": "${GITHUB_RUN_ATTEMPT}"
              },
              "resolvedDependencies": [
                {
                  "uri": "git+https://github.com/${GITHUB_REPOSITORY}",
                  "digest": {
                    "gitCommit": "${GITHUB_SHA}"
                  }
                }
              ]
            },
            "runDetails": {
              "builder": {
                "id": "https://github.com/${GITHUB_REPOSITORY}/.github/workflows/${GITHUB_WORKFLOW}"
              },
              "metadata": {
                "invocationId": "https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
              }
            }
          }
          EOF
          cosign attest --yes --predicate provenance.json --type https://slsa.dev/provenance/v1 "${{ steps.patched_digest.outputs.ref }}"
